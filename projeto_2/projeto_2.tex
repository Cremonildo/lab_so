\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[brazilian]{babel}

\author{Gabriel de Paula e Lima  587710\\
        Giovana Vieira de Morais  587591}
\title{Relatório Projeto 2}
\begin{document}

\maketitle

\newpage

\section*{Relatório}

As funcionalidades solicitadas para serem implementadas foram:

\begin{itemize}
\item{Permissão de recebimento de argumentos para os comandos executados}
\item{Suporte para execução de comandos em segundo plano}
\item{Redirecionamento de entrada e saída padrão para arquivos}
\end{itemize}

A seguir explicaremos como implementamos cada uma dessas funções

\section*{Permissão de recebimento de argumentos para os comandos executados}
 A função supracitada foi implementada da seguinte maneira:

 Separamos cada string de entrada a fim de armazenarmos individualmente o comando e cada argumento digitado
 deste modo criando um vetor de argumentos.
 Então criamos um novo processo utilizando a chamada de sistema \texttt{fork},
 a qual cria esse novo processo idêntico ao processo-pai (Processo que chamou o \texttt{fork}),
 sendo o processo filho apenas diferente do pai em seu id (\texttt{pid}) que é igual a 0.
 Após isso utilizamos a chamada de sistema \texttt{execvp},
 a qual irá substituir o conteúdo do processo filho pelo comando que queremos executar.
 Assim \texttt{execvp} recebe o comando digitado na linha de comando e o vetor de argumentos obtido por nós.
 Para então executar o comando com seus argumentos.

\section*{Suporte para execução de comandos em segundo plano}
A função supracitada foi implementada da seguinte maneira:

Ao recebermos todos os argumentos do comando os armazenamos em um vetor de argumentos como citado no comando descrito anteriormente a este, verificamos se o símbolo de execução em segundo plano(\&) se encontra nesse vetor.
Se encontramos ele, o removemos e sinalizamos um flag de execução de segundo plano.
Após criarmos o novo processo através da chamada de sistema \texttt{fork},
verificamos se a flag de execução em segundo plano está sinalizada.
Estando ela sinalizada, utilizamos a chamada de sistema \texttt{waitpid},
chamada esta a qual por padrão normalmente suspende a execução do processo-pai,
nesse caso a própria shell, até uma mudança de estado do processo-filho.
Porém utilizamos a opção \texttt{WNOHANG} a fim do processo não esperar
a mudança de estado do processo-filho, assim executando o comando requerido em segundo plano.

\section*{Redirecionamento de entrada e saída padrão para arquivos}
A função supracitada foi implementada da seguinte maneira:

Para o redirecionamento de entrada, verificamos se há símbolo correspondente a redirecionamento de entrada (\texttt{<})
na entrada da shell.
Ao identificarmos o símbolo, armazenamos o nome do arquivo de entrada que vem logo após o \texttt{<}
e sinalizamos a flag de redirecionamento de entrada.
Todo o processo descrito até o momento é feito de modo igual para o redirecionamento de saída e seu símbolo(\texttt{>}).
Então criamos o novo processo através da chamada de sistema \texttt{fork}
e verificamos as flags de redirecionamentos.
Se tiverem sido sinalizadas, usamos a função de entrada e saída
\texttt{freopen}, redirecionando então os fluxos padrões para o arquivo o qual o nome já teve o armazenamento citado anteriormente.
No caso de ser redirecionamento de entrada, redirecionamos o arquivo para a entrada padrão \texttt{stdin},
no caso de redirecionamento de saída, redirecionamos a saída padrão \texttt{stdout} para o arquivo.
A chamada do redirecionamento foi feita após a chamada \texttt{fork},
pois se o fizéssemos antes dele, estariamos fazendo redirecionamento do processo-pai(shell),
quando na verdade desejamos fazer redirecionamento do processo-filho(comando executado pela shell).


% funções implementadas:
%   shell com funções com mais de um argumento
%       execvp
%   comandos em segundo plano
%       waitpid + argumento pra não esperar um processo terminar antes de
%       iniciar o outro
%   comandos usando entrada e saída padrão
%

% iniciar uma seção: \section{Nome da seção}
% \begin{itemize}
% \item{bklabkabka}
% \end{itemize}
% \texttt <- pra trechos de código OU usar a biblioteca pseudoalg ou algo assim sei lá se vira (tem a algorithm tbm)

\end{document}
